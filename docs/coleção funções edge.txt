supabase\functions\auth_pre_signup_domain_guard\index.ts

import { serve } from "https://deno.land/std@0.203.0/http/server.ts";
import { crypto } from "https://deno.land/std@0.203.0/crypto/mod.ts";

/**
 * Supabase Auth Hook — Before User Created
 * Contrato REAL do Supabase:
 * - Valida assinatura HMAC
 * - Espera status 2xx ou erro
 * - Ignora payload extra
 */

const HOOK_SECRET = Deno.env.get("AUTH_HOOK_SECRET");
const EXPECTED_PROJECT_URL = Deno.env.get("SUPABASE_URL");
const ALLOWED_DOMAIN = "@viang.com.br";
const MASTER_EMAIL = "alangattiboni@gmail.com";

serve(async (req) => {
    const requestId = crypto.randomUUID();
    const start = Date.now();

    const log = (level: "info" | "warn" | "error", msg: string, extra: any = {}) => {
        console.log(JSON.stringify({
            level,
            msg,
            requestId,
            ts: new Date().toISOString(),
            ...extra,
        }));
    };

    try {
        if (!HOOK_SECRET) {
            log("error", "HOOK_SECRET ausente");
            return new Response("Hook misconfigured", { status: 500 });
        }


        // 2️⃣ Parse seguro do payload
        let payload: any;
        try {
            payload = JSON.parse(rawBody);
        } catch {
            log("error", "JSON inválido");
            return new Response("Invalid JSON", { status: 400 });
        }

        const email = payload?.user?.email;
        const userId = payload?.user?.id;

        if (!email || !userId) {
            log("warn", "Payload incompleto", { payload });
            return new Response("Invalid payload", { status: 400 });
        }

        // 3️⃣ Log de contrato implícito
        log("info", "Signup attempt", {
            email,
            userId,
            projectUrl: EXPECTED_PROJECT_URL,
            hookUrl: req.url,
        });

        // 4️⃣ Exceção master
        if (email === MASTER_EMAIL) {
            log("info", "Master bypass");
            return ok(start, requestId);
        }

        // 5️⃣ Regra de domínio
        if (!email.endsWith(ALLOWED_DOMAIN)) {
            log("warn", "Domínio não autorizado", { email });
            return new Response(
                JSON.stringify({ error: "Domínio não autorizado" }),
                { status: 403 }
            );
        }

        // 6️⃣ Sucesso
        return ok(start, requestId);

    } catch (err) {
        log("error", "Erro interno", { error: String(err) });
        return new Response("Internal error", { status: 500 });
    }
});

function ok(start: number, requestId: string) {
    return new Response(null, {
        status: 200,
        headers: {
            "x-auth-hook": "pre-signup-domain-guard",
            "x-request-id": requestId,
            "x-processing-ms": String(Date.now() - start),
        },
    });
}


---

supabase\functions\home-dashboard\index.ts

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error("Supabase env vars missing");
}

const supabase = createClient(
    SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY,
    { auth: { persistSession: false } }
);

const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
};

type DashboardPeriod =
    | { type: "preset"; preset: "7d" | "30d" | "90d"; start_date: null; end_date: null }
    | { type: "custom"; preset: null; start_date: string; end_date: string };

function iso(d: Date) {
    return d.toISOString().slice(0, 10);
}

function resolvePeriod(p: DashboardPeriod) {
    if (p.type === "custom") {
        return { start_date: p.start_date, end_date: p.end_date };
    }

    const end = new Date();
    const start = new Date(end);

    if (p.preset === "7d") start.setDate(end.getDate() - 7);
    if (p.preset === "30d") start.setDate(end.getDate() - 30);
    if (p.preset === "90d") start.setDate(end.getDate() - 90);

    return { start_date: iso(start), end_date: iso(end) };
}

async function rpc(fn: string, period: DashboardPeriod) {
    const { start_date, end_date } = resolvePeriod(period);

    const { data, error } = await supabase
        .schema("dashboard")
        .rpc(fn, {
            p_start_date: start_date,
            p_end_date: end_date,
        });

    if (error) throw error;
    return data;
}

serve(async (req) => {
    if (req.method === "OPTIONS") {
        return new Response("ok", { headers: corsHeaders });
    }

    if (req.method !== "POST") {
        return new Response(JSON.stringify({ error: "Method not allowed" }), {
            status: 405,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
    }

    try {
        const url = new URL(req.url);
        const route = url.pathname.split("/").pop()!;
        const period = await req.json();

        const map: Record<string, () => Promise<any>> = {
            "kpi-receita-bruta": () => rpc("fn_kpi_receita_bruta", period),
            "chart-receita-por-semana": () => rpc("fn_chart_receita_por_semana", period),
            "chart-pedidos-dia": () => rpc("fn_chart_pedidos_por_dia", period),
            "chart-unidades-categoria": () => rpc("fn_chart_unidades_categoria", period),
            "chart-top-skus": () => rpc("fn_chart_top_skus", period),
            "chart-distribuicao-categoria": () => rpc("fn_chart_distribuicao_categoria", period),
            "chart-ticket-medio-categoria": () => rpc("fn_chart_ticket_medio_categoria", period),
            "chart-receita-cliente-semana": () => rpc("fn_chart_receita_cliente_semana", period),
        };

        if (!map[route]) {
            return new Response(JSON.stringify({ error: "Unknown route" }), {
                status: 404,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            });
        }

        const data = await map[route]();

        return new Response(JSON.stringify(data ?? []), {
            status: 200,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
        });

    } catch (err) {
        console.error("[home-dashboard]", err);
        return new Response(
            JSON.stringify({
                error: "Internal error",
                details: (err instanceof Error) ? err.message : String(err),
            }),
            {
                status: 500,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            }
        );
    }
});


---

supabase\functions\produtos-dashboard\index.ts

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* =====================================================
 *  ENV
 * ===================================================== */

const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error("Supabase env vars missing");
}


if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error("Supabase env vars missing");
}

const supabase = createClient(
    SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY,
    { auth: { persistSession: false } }
);

/* =====================================================
 *  CORS
 * ===================================================== */

const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers":
        "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
};

/* =====================================================
 *  PERÍODO — IGUAL À HOME
 * ===================================================== */

type DashboardPeriod =
    | { type: "preset"; preset: "7d" | "30d" | "90d"; start_date: null; end_date: null }
    | { type: "custom"; preset: null; start_date: string; end_date: string };

function iso(d: Date) {
    return d.toISOString().slice(0, 10);
}

function resolvePeriod(p: DashboardPeriod) {
    if (p.type === "custom") {
        return { start_date: p.start_date, end_date: p.end_date };
    }

    const end = new Date();
    const start = new Date(end);

    if (p.preset === "7d") start.setDate(end.getDate() - 7);
    if (p.preset === "30d") start.setDate(end.getDate() - 30);
    if (p.preset === "90d") start.setDate(end.getDate() - 90);

    return { start_date: iso(start), end_date: iso(end) };
}

/* =====================================================
 *  RPC — IGUAL À HOME
 * ===================================================== */

async function rpc(fn: string, period: DashboardPeriod) {
    const { start_date, end_date } = resolvePeriod(period);

    const { data, error } = await supabase
        .schema("dashboard")
        .rpc(fn, {
            p_start_date: start_date,
            p_end_date: end_date,
        });

    if (error) throw error;
    return data;
}

/* =====================================================
 *  SERVER
 * ===================================================== */

serve(async (req) => {
    if (req.method === "OPTIONS") {
        return new Response("ok", { headers: corsHeaders });
    }

    if (req.method !== "POST") {
        return new Response(
            JSON.stringify({ error: "Method not allowed" }),
            {
                status: 405,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            }
        );
    }

    try {
        const url = new URL(req.url);
        const route = url.pathname.split("/").pop();

        if (!route) {
            return new Response(
                JSON.stringify({ error: "Invalid route" }),
                {
                    status: 400,
                    headers: { ...corsHeaders, "Content-Type": "application/json" },
                }
            );
        }

        const period = await req.json();

        /* =================================================
         *  MAPA DE ENDPOINTS — PRODUTOS (NORMALIZADO)
         * ================================================= */

        const map: Record<string, () => Promise<any>> = {
            "alerts-pior-queda-produtos": () =>
                rpc("fn_pior_queda_produtos_semana", period),

            "alerts-pior-queda-vendedores": () =>
                rpc("fn_pior_queda_vendedores_semana", period),

            "alerts-pior-margem-produto": () =>
                rpc("fn_pior_margem_implicita_produto", period),

            "chart-margem-produto-bubble": async () => {
                const { data, error } = await supabase
                    .schema("dashboard")
                    .rpc("fn_margem_operacional_por_produto");

                if (error) throw error;
                return data;
            },

            "chart-giro-produtos-tempo": async () => {
                const { start_date, end_date } = resolvePeriod(period);

                const { data, error } = await supabase
                    .schema("dashboard")
                    .rpc("fn_giro_produtos_tempo", {
                        p_data_inicio: start_date,
                        p_data_fim: end_date,
                    });

                if (error) throw error;
                return data;
            },

            "table-curva-abc-produtos": async () => {
                const { start_date, end_date } = resolvePeriod(period);

                const { data, error } = await supabase
                    .schema("dashboard")
                    .rpc("fn_curva_abc_produtos", {
                        p_data_inicio: start_date,
                        p_data_fim: end_date,
                    });

                if (error) throw error;
                return data;
            },

            "table-tabelao-produtos": async () => {
                const { data, error } = await supabase
                    .schema("dashboard")
                    .rpc("fn_tabelao_produtos", {
                        p_data_inicio: resolvePeriod(period).start_date,
                        p_data_fim: resolvePeriod(period).end_date,
                    });

                if (error) throw error;

                return data ?? [];
            },
        };

        if (!map[route]) {
            return new Response(
                JSON.stringify({ error: "Unknown route" }),
                {
                    status: 404,
                    headers: { ...corsHeaders, "Content-Type": "application/json" },
                }
            );
        }

        const data = await map[route]();

        return new Response(JSON.stringify(data ?? []), {
            status: 200,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
        });

    } catch (err) {
        console.error("[produtos-dashboard]", err);

        return new Response(
            JSON.stringify({
                error: "Internal error",
                details: err instanceof Error ? err.message : String(err),
            }),
            {
                status: 500,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            }
        );
    }
});


---

supabase\functions\users-config\index.ts

// supabase/functions/users-config/index.ts

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* =====================================================
 * ENV
 * ===================================================== */
const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error("Missing Supabase environment variables");
}

/* =====================================================
 * CLIENT
 * ===================================================== */
const supabase = createClient(
    SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY,
    { auth: { persistSession: false } }
);

/* =====================================================
 * CORS
 * ===================================================== */
const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers":
        "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
};

/* =====================================================
 * HANDLERS
 * ===================================================== */
async function listUsers() {
    const { data, error } = await supabase
        .schema("dashboard")
        .from("users")
        .select(`
            id,
            email,
            role,
            permission_level,
            status,
            is_master,
            created_at,
            updated_at
        `)
        .order("created_at", { ascending: true });

    if (error) throw error;

    return data ?? [];
}

/* =====================================================
 * SERVER
 * ===================================================== */
serve(async (req) => {
    if (req.method === "OPTIONS") {
        return new Response("ok", { headers: corsHeaders });
    }

    if (req.method !== "POST") {
        return new Response(
            JSON.stringify({ error: "Method not allowed" }),
            {
                status: 405,
                headers: {
                    ...corsHeaders,
                    "Content-Type": "application/json",
                },
            }
        );
    }

    try {
        const route = new URL(req.url).pathname.split("/").pop();

        const map: Record<string, () => Promise<any>> = {
            list: () => listUsers(),
        };

        if (!route || !map[route]) {
            return new Response(
                JSON.stringify({ error: "Unknown route" }),
                { status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        const data = await map[route]();

        return new Response(JSON.stringify(data), {
            status: 200,
            headers: {
                ...corsHeaders,
                "Content-Type": "application/json",
            },
        });
    } catch (err) {
        console.error("[users-config]", err);

        return new Response(
            JSON.stringify({
                error: "Internal error",
                details:
                    err instanceof Error ? err.message : String(err),
            }),
            {
                status: 500,
                headers: {
                    ...corsHeaders,
                    "Content-Type": "application/json",
                },
            }
        );
    }
});


---
supabase\functions\clientes\index.ts


import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error("Supabase env vars missing");
}

const supabase = createClient(
    SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY,
    {
        auth: { persistSession: false },
        db: { schema: "dashboard" }
    }
);

const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers":
        "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
};

serve(async (req) => {
    if (req.method === "OPTIONS") {
        return new Response("ok", { headers: corsHeaders });
    }

    try {
        const url = new URL(req.url);
        const route = url.pathname.split("/").pop();

        if (route !== "clientes") {
            return new Response(JSON.stringify([]), {
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            });
        }

        // =====================================================
        // BODY OPCIONAL
        // =====================================================
        let body: any = null;
        try {
            body = await req.json();
        } catch {
            body = null;
        }

        // =====================================================
        // 1) SAVE OVERRIDES
        // =====================================================
        if (body?.action === "save_overrides" && Array.isArray(body.payload)) {

            const rows = body.payload.map((item: any) => ({
                client_id: item.client_id,
                ml_email_override: item.ml_email ?? null,
                ml_phone_override: item.ml_phone ?? null,
                ml_perma_link_override: item.ml_perma_link ?? null,
                ml_logo_override: item.ml_logo ?? null,
                updated_at: new Date().toISOString()
            }));

            const { error } = await supabase
                .from("client_overrides")
                .upsert(rows, { onConflict: "client_id" });

            if (error) {
                throw error;
            }

            return new Response(
                JSON.stringify([]),
                { headers: { ...corsHeaders, "Content-Type": "application/json" } }
            );
        }

        // =====================================================
        // 2) LIST CLIENTES
        // =====================================================

        // 2.1 api_tokens (fonte da verdade)
        const { data: tokens, error: tokensError } = await supabase
            .from("api_tokens")
            .select(`
                ml_logo,
                display_name,
                status,
                expires_at,
                client_id,
                user_id,
                ml_nickname,
                ml_first_name,
                ml_last_name,
                ml_email,
                ml_phone,
                ml_seller_status,
                ml_points,
                ml_site_id,
                ml_perma_link
            `)
            .eq("platform", "mercado_livre")
            .order("display_name", { ascending: true });

        if (tokensError) {
            throw tokensError;
        }

        // 2.2 overrides (sem relação declarada)
        const { data: overrides, error: overridesError } = await supabase
            .from("client_overrides")
            .select(`
                client_id,
                ml_logo_override,
                ml_email_override,
                ml_phone_override,
                ml_perma_link_override
            `);

        if (overridesError) {
            throw overridesError;
        }

        // 2.3 map de overrides por client_id
        const overridesMap = new Map(
            (overrides ?? []).map(o => [o.client_id, o])
        );

        // 2.4 merge final
        const merged = (tokens ?? []).map(row => {
            const o = overridesMap.get(row.client_id);

            return {
                ml_logo: o?.ml_logo_override ?? row.ml_logo,
                display_name: row.display_name,
                status: row.status,
                expires_at: row.expires_at,

                client_id: row.client_id,
                user_id: row.user_id,
                ml_nickname: row.ml_nickname,
                ml_first_name: row.ml_first_name,
                ml_last_name: row.ml_last_name,

                ml_email: o?.ml_email_override ?? row.ml_email,
                ml_phone: o?.ml_phone_override ?? row.ml_phone,

                ml_seller_status: row.ml_seller_status,
                ml_points: row.ml_points,
                ml_site_id: row.ml_site_id,

                ml_perma_link: o?.ml_perma_link_override ?? row.ml_perma_link
            };
        });

        return new Response(JSON.stringify(merged), {
            headers: { ...corsHeaders, "Content-Type": "application/json" },
        });

    } catch (err) {
        console.error("[clientes]", err);

        // CONTRATO DO FRONT: SEMPRE ARRAY
        return new Response(JSON.stringify([]), {
            headers: { ...corsHeaders, "Content-Type": "application/json" },
            status: 200,
        });
    }
});

---
// supabase/functions/cliente-detalhe/index.ts

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* =====================================================
 *  ENV
 * ===================================================== */

const SUPABASE_URL = Deno.env.get("SUPABASE_URL");
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    throw new Error("Supabase env vars missing");
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {
    auth: { persistSession: false },
});

/* =====================================================
 *  CORS
 * ===================================================== */

const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers":
        "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
};

/* =====================================================
 *  PERÍODO — igual ao padrão das edges existentes
 * ===================================================== */

type DashboardPeriod =
    | { type: "preset"; preset: "7d" | "30d" | "90d"; start_date: null; end_date: null }
    | { type: "custom"; preset: null; start_date: string; end_date: string };

function iso(d: Date) {
    return d.toISOString().slice(0, 10);
}

function resolvePeriod(p: DashboardPeriod) {
    if (p.type === "custom") {
        return { start_date: p.start_date, end_date: p.end_date };
    }

    const end = new Date();
    const start = new Date(end);

    if (p.preset === "7d") start.setDate(end.getDate() - 7);
    if (p.preset === "30d") start.setDate(end.getDate() - 30);
    if (p.preset === "90d") start.setDate(end.getDate() - 90);

    return { start_date: iso(start), end_date: iso(end) };
}

/* =====================================================
 *  RPC — cliente + período
 * ===================================================== */

async function rpcCliente(fn: string, client_id: string, period: DashboardPeriod) {
    const { start_date, end_date } = resolvePeriod(period);

    const { data, error } = await supabase
        .schema("dashboard")
        .rpc(fn, {
            p_client_id: client_id,
            p_start_date: start_date,
            p_end_date: end_date,
        });

    if (error) throw error;
    return data ?? [];
}

/* =====================================================
 *  SAÚDE OPERACIONAL — agregação no backend (contagens)
 * ===================================================== */

async function loadSaudeOperacional(client_id: string, period: DashboardPeriod) {
    console.log("[cliente-detalhe][saude-operacional] start", {
        client_id,
        period,
    });

    const gargalosRows = await rpcCliente(
        "fn_gargalos_operacionais_por_sku_cliente",
        client_id,
        period
    );

    const riscoRows = await rpcCliente(
        "fn_risco_operacional_por_sku_cliente",
        client_id,
        period
    );

    // Contagem distinta por sku (sem inferir colunas extras)
    const gargalosSet = new Set(
        (gargalosRows ?? []).map((r: any) => String(r?.sku ?? ""))
            .filter((v: string) => v.length > 0)
    );

    const riscoSet = new Set(
        (riscoRows ?? []).map((r: any) => String(r?.sku ?? ""))
            .filter((v: string) => v.length > 0)
    );

    const payload = {
        gargalos_operacionais: gargalosSet.size,
        skus_em_risco: riscoSet.size,
    };

    console.log("[cliente-detalhe][saude-operacional] done", {
        gargalos_rows: (gargalosRows ?? []).length,
        risco_rows: (riscoRows ?? []).length,
        payload,
    });

    return payload;
}

/* =====================================================
 *  SERVER
 * ===================================================== */

serve(async (req) => {
    if (req.method === "OPTIONS") {
        return new Response("ok", { headers: corsHeaders });
    }

    if (req.method !== "POST") {
        return new Response(JSON.stringify({ error: "Method not allowed" }), {
            status: 405,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
    }

    try {
        const url = new URL(req.url);
        const route = url.pathname.split("/").pop();

        if (!route) {
            return new Response(JSON.stringify({ error: "Invalid route" }), {
                status: 400,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            });
        }

        const body = await req.json();

        const client_id = body?.client_id;
        if (!client_id) {
            return new Response(JSON.stringify({ error: "client_id missing" }), {
                status: 400,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            });
        }

        // period = resto do body (o front manda {client_id, type, preset, start_date, end_date})
        const period: DashboardPeriod = {
            type: body?.type,
            preset: body?.preset ?? null,
            start_date: body?.start_date ?? null,
            end_date: body?.end_date ?? null,
        };

        console.log("[cliente-detalhe] request", {
            route,
            client_id,
            period,
        });

        const map: Record<string, () => Promise<any>> = {
            // KPIs
            "kpi-receita-bruta": () =>
                rpcCliente("fn_kpi_receita_bruta_cliente", client_id, period),

            "kpi-ticket-medio": () =>
                rpcCliente("fn_kpi_ticket_medio_cliente", client_id, period),

            // Saúde Operacional (novo card)
            "saude-operacional": () =>
                loadSaudeOperacional(client_id, period),

            // Charts
            "chart-receita-por-semana": () =>
                rpcCliente("fn_chart_receita_por_semana_cliente", client_id, period),

            "chart-pedidos-dia": () =>
                rpcCliente("fn_chart_pedidos_por_dia_cliente", client_id, period),

            "chart-unidades-categoria": () =>
                rpcCliente("fn_chart_unidades_categoria_cliente", client_id, period),

            "chart-distribuicao-categoria": () =>
                rpcCliente("fn_chart_distribuicao_categoria_cliente", client_id, period),

            "chart-top-skus": () =>
                rpcCliente("fn_chart_top_skus_cliente", client_id, period),

            // Alerts
            "alerts-pior-queda-produtos": () =>
                rpcCliente("fn_pior_queda_produtos_semana_cliente", client_id, period),

            // Produtos (cliente) — usados na página Cliente Detalhe
            "chart-margem-produto-bubble": () =>
                rpcCliente("fn_margem_operacional_por_produto_cliente", client_id, period),

            "table-curva-abc-produtos": () =>
                rpcCliente("fn_curva_abc_produtos_cliente", client_id, period),

            "table-tabelao-produtos": () =>
                rpcCliente("fn_tabelao_produtos_cliente", client_id, period),
        };

        if (!map[route]) {
            return new Response(JSON.stringify({ error: "Unknown route" }), {
                status: 404,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            });
        }

        const data = await map[route]();

        return new Response(JSON.stringify(data ?? []), {
            status: 200,
            headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
    } catch (err) {
        console.error("[cliente-detalhe]", err);

        return new Response(
            JSON.stringify({
                error: "Internal error",
                details: err instanceof Error ? err.message : String(err),
            }),
            {
                status: 500,
                headers: { ...corsHeaders, "Content-Type": "application/json" },
            },
        );
    }
});

---

supabase\functions\viang-ai\index.ts

import { serve } from "https://deno.land/std@0.224.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
    "Access-Control-Allow-Methods": "POST, OPTIONS"
};

const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY")!;

const supabase = createClient(
    SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY,
    {
        db: {
            schema: "dashboard"
        }
    }
);

type ActionType = "explain" | "analyze" | "ask";
type ContextType = "page" | "element";

interface ViangRequest {
    client_id: string;
    page: string;
    context: ContextType;

    page_semantic_context?: any;

    element_id?: string | null;
    element_type?: string | null;
    edge_function?: string | null;
    edge_path?: string | null;

    action_type: ActionType;
    user_prompt?: string | null;

    period: {
        start: string;
        end: string;
    };
}

serve(async (req) => {
    try {
        if (req.method === "OPTIONS") {
            return new Response("ok", { headers: corsHeaders });
        }

        if (req.method !== "POST") {
            return new Response("Method not allowed", {
                status: 405,
                headers: corsHeaders
            });
        }

        let payload: ViangRequest;

        try {
            payload = await req.json();
        } catch {
            return new Response("Invalid JSON payload", {
                status: 400,
                headers: corsHeaders
            });
        }

        const {
            client_id,
            page,
            context,
            element_id = null,
            element_type = null,
            edge_function = null,
            edge_path = null,
            action_type,
            user_prompt = null,
            period
        } = payload;

        // ===== Validações explícitas (sem inferência) =====
        if (!client_id || !page || !context || !action_type || !period) {
            return new Response("Missing required fields", {
                status: 400,
                headers: corsHeaders
            });
        }

        if (context === "element") {
            if (!element_id || !element_type || !edge_function || !edge_path) {
                return new Response(
                    "element_id, element_type, edge_function and edge_path are required when context=element",
                    {
                        status: 400,
                        headers: corsHeaders
                    }
                );
            }
        }

        if (action_type === "ask" && !user_prompt) {
            return new Response("user_prompt is required for action_type=ask", {
                status: 400,
                headers: corsHeaders
            });
        }

        // ===== Hash determinístico do cache =====
        const hashBase = JSON.stringify({
            client_id,
            page,
            context,
            element_id,
            action_type,
            period,
            user_prompt: action_type === "ask" ? user_prompt : null
        });

        const hash = await crypto.subtle.digest(
            "SHA-256",
            new TextEncoder().encode(hashBase)
        ).then(buf =>
            Array.from(new Uint8Array(buf))
                .map(b => b.toString(16).padStart(2, "0"))
                .join("")
        );

        // ===== 1) Tenta ler cache válido =====
        const { data: cached } = await supabase
            .from("insight_cache")
            .select("response")
            .eq("hash", hash)
            .gt("expires_at", new Date().toISOString())
            .limit(1)
            .maybeSingle();

        if (cached?.response) {
            return new Response(
                JSON.stringify({ source: "cache", response: cached.response }),
                {
                    headers: {
                        ...corsHeaders,
                        "Content-Type": "application/json"
                    }
                }
            );
        }

        // ===== 2) Limpa lixo vencido desse contexto =====
        await supabase
            .from("insight_cache")
            .delete()
            .eq("client_id", client_id)
            .eq("page", page)
            .eq("scope", context)
            .eq("action_type", action_type)
            .lte("expires_at", new Date().toISOString());

        let elementData: any = null;

        if (context === "element") {
            const elementRes = await fetch(
                `${SUPABASE_URL}/functions/v1/${edge_function}${edge_path}`,
                {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        client_id,
                        element_id,
                        period
                    })
                }
            );

            if (!elementRes.ok) {
                const err = await elementRes.text();
                return new Response(err, {
                    status: 500,
                    headers: corsHeaders
                });
            }

            const raw = await elementRes.json();

            elementData =
                Array.isArray(raw)
                    ? {
                        exists: true,
                        has_data: raw.length > 0,
                        rows: raw,
                        count: raw.length
                    }
                    : {
                        exists: false,
                        has_data: false,
                        rows: [],
                        count: 0
                    };
        }

        let pageData: any = null;

        if (context === "page" && action_type === "analyze") {
            const components = payload.page_semantic_context?.components;

            if (!Array.isArray(components)) {
                return new Response(
                    "components ausente ou inválido no page_semantic_context",
                    { status: 400, headers: corsHeaders }
                );
            }

            const results: Record<string, any> = {};

            for (const c of components) {
                if (!c?.data_source?.name) {
                    continue;
                }

                const res = await fetch(
                    `${SUPABASE_URL}/functions/v1/home-dashboard/${c.data_source.name}`,
                    {
                        method: "POST",
                        headers: {
                            "Authorization": `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            type: "custom",
                            preset: null,
                            start_date: payload.period.start,
                            end_date: payload.period.end
                        })
                    }
                );

                if (!res.ok) {
                    const err = await res.text();
                    return new Response(err, {
                        status: 500,
                        headers: corsHeaders
                    });
                }

                const raw = await res.json();

                const normalized =
                    Array.isArray(raw)
                        ? {
                            exists: true,
                            has_data: raw.length > 0,
                            rows: raw,
                            count: raw.length
                        }
                        : {
                            exists: false,
                            has_data: false,
                            rows: [],
                            count: 0
                        };

                results[c.id] = {
                    id: c.id,
                    type: c.type,
                    data_source: c.data_source.name,
                    state: normalized.has_data ? "populated" : "empty",
                    rows: normalized.rows,
                    count: normalized.count
                };
            }

            pageData = results;
        }


        // ===== 3) Define modelo conforme ação =====
        let model = "gpt-4.1-mini";

        if (action_type === "analyze" && context === "page") {
            model = "gpt-5.2";
        } else if (action_type === "analyze") {
            model = "gpt-4.1";
        } else if (action_type === "explain" && context === "page") {
            model = "gpt-4.1";
        }

        // ===== 4) Monta prompt base (simples e controlado) =====

        // 4.1 — Carrega dicionário oficial (fonte única da verdade)
        const { data: dictionaryRows, error: dictError } = await supabase
            .from("vw_data_dictionary_markdown")
            .select("*");

        if (dictError) {
            console.error("[viang-ai] erro ao carregar dicionário", dictError);
        }

        const dataDictionary =
            Array.isArray(dictionaryRows)
                ? dictionaryRows.map(r => r.markdown_doc).join("\n")
                : "";

        // 4.2 — Prompt institucional (sem inferência)
        const systemPrompt = `
Você é a v.I.A.ng, a IA analítica da plataforma Viang.

Você fala com autoridade institucional.
Você nunca generaliza dashboards.
Você nunca descreve abstrações que não existam no produto.

FONTE ÚNICA DE VERDADE CONCEITUAL:
${dataDictionary}

Regras absolutas:
- Use EXCLUSIVAMENTE os conceitos definidos acima.
- Nunca invente métricas, entidades ou significados.
- Nunca descreva algo que não exista na página.
- Nunca use linguagem genérica ou defensiva.
`;

        let userContent = "";

        if (action_type === "explain") {
            userContent = context === "page"
                ? `
Você está explicando uma página da plataforma Viang.

Contexto semântico da página:
${JSON.stringify(payload.page_semantic_context, null, 2)}

Explique de forma institucional, clara e aplicada o papel dessa página,
como ela funciona e para que serve no contexto da Viang.
`
                : `
Explique o elemento "${element_id}" (tipo: ${element_type}) da página "${page}".

Dados reais do elemento:
${JSON.stringify(elementData, null, 2)}
`;
        }

        if (action_type === "analyze") {
            userContent = context === "page"
                ? `Você está analisando a página "${page}" no período de ${period.start} a ${period.end}.

Interprete os dados como um gestor faria ao olhar este dashboard.

Regras de linguagem (obrigatórias):
- NÃO mencione termos técnicos (payload, JSON, schema, endpoint, RPC, edge, função, query, view, tabela, etc.).
- NÃO cite nomes de IDs técnicos (como "chart-..." ou "kpi-...") no texto final.
- Use linguagem clara, direta e executiva.

Regras de análise (obrigatórias):
- Considere SOMENTE os componentes que possuem dados no período.
- Quando um indicador estiver zerado ou ausente, explique o impacto disso no negócio.
- Se houver divergência entre indicadores, proponha até 2 hipóteses de negócio, sem tecnicês.

Formato:
- Texto corrido
- Conclusões práticas
- 3 ações recomendadas

Dados consolidados da página:
${JSON.stringify(pageData, null, 2)}`
                : `Você está analisando um elemento específico da página "${page}" no período de ${period.start} a ${period.end}.

Interprete os dados como um gestor faria ao olhar **apenas este indicador**, considerando impacto, tendência e tomada de decisão.

Regras de linguagem (obrigatórias):
- NÃO mencione termos técnicos (payload, JSON, schema, endpoint, RPC, edge, função, query, view, tabela, etc.).
- NÃO cite nomes de IDs técnicos no texto final.
- Fale sempre em termos de negócio, nunca de implementação.
- Seja direto, executivo e acionável.

    Regras de análise (obrigatórias):
    - Se \`has_data = false\`, explique o impacto prático da ausência de dados.
- Se houver dados, descreva o comportamento observado (tendência, concentração, variação).
- Não descreva o gráfico. Descreva o que ele **significa**.
- Não generalize para a página inteira.

Formato:
- 1 parágrafo executivo
- 3 insights objetivos
- 2 ações recomendadas

Dados do elemento:
${JSON.stringify(elementData, null, 2)}`;
        }

        // ===== 5) Chamada OpenAI =====
        const openaiRes = await fetch("https://api.openai.com/v1/responses", {
            method: "POST",
            headers: {
                "Authorization": `Bearer ${OPENAI_API_KEY}`,
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                model,
                input: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userContent }
                ]
            })
        });

        if (!openaiRes.ok) {
            const err = await openaiRes.text();
            return new Response(err, {
                status: 500,
                headers: corsHeaders
            });
        }

        const openaiJson = await openaiRes.json();
        const aiResponse =
            openaiJson.output_text ??
            openaiJson.output?.[0]?.content?.[0]?.text ??
            "Sem resposta";

        // ===== 6) Salva no cache =====
        await supabase.from("insight_cache").insert({
            client_id,
            page,
            scope: context,
            element_id,
            action_type,
            prompt: user_prompt,
            context: payload,
            response: aiResponse,
            hash,
            expires_at: new Date(Date.now() + 30 * 60 * 1000).toISOString()
        });

        return new Response(
            JSON.stringify({ source: "openai", response: aiResponse }),
            {
                headers: {
                    ...corsHeaders,
                    "Content-Type": "application/json"
                }
            }
        );
    } catch (err) {
        console.error("[viang-ai] erro não tratado", err);
        return new Response(
            "Internal Server Error",
            {
                status: 500,
                headers: corsHeaders
            }
        );
    }
});